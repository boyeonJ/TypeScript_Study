# νƒ€μ…νΈν™μ΄λ€?
> π‘©β€ λ‹΄λ‹Ήμ: μ •λ³΄μ—°<br/>

νƒ€μ…μ¤ν¬λ¦½νΈ(TypeScript)μ "νƒ€μ… νΈν™μ„±"μ€ λ‘ κ°€μ§€ νƒ€μ… κ°„μ— κ°’μ΄ ν• λ‹Ή κ°€λ¥ν•μ§€ μ—¬λ¶€λ¥Ό λ‚νƒ€λ‚΄λ” κ°λ…μ…λ‹λ‹¤. μ¦‰, μ–΄λ–¤ νƒ€μ…μ κ°’μ΄ λ‹¤λ¥Έ νƒ€μ…μΌλ΅ λ³€ν™λκ±°λ‚ ν• λ‹Ήλ  μ μλ”μ§€λ¥Ό νλ‹¨ν•λ” κ·μΉ™μ λ¨μμ…λ‹λ‹¤. μ΄λ¥Ό ν†µν•΄ μ½”λ“ μ‘μ„± μ‹ λ¶ν•„μ”ν• μ¤λ¥λ¥Ό λ°©μ§€ν•κ³  νƒ€μ… μ•μ •μ„±μ„ μ μ§€ν•  μ μμµλ‹λ‹¤.

νƒ€μ…μ¤ν¬λ¦½νΈμ νƒ€μ… νΈν™μ„±μ€ 4κ°€μ§€λ΅ λ‚λ„μ–΄μ„ μ΄ν•΄ν•  μ μμµλ‹λ‹¤.

### 1. **νƒ€μ…μ κµ¬μ΅°μ  νΈν™μ„± (Structural Compatibility)** 
νƒ€μ…μ κµ¬μ΅°μ  ν•νƒκ°€ μ–Όλ§λ‚ μ μ‚¬ν•μ§€λ¥Ό κ³ λ ¤ν•©λ‹λ‹¤. μ¦‰, νƒ€μ…μ ν•(type, interface..)μ΄ μ•„λ‹ νƒ€μ…μ κµ¬μ΅°(κ°™μ€ μ†μ„±κ³Ό νƒ€μ…μΈμ§€)λ¥Ό ν†µν•΄ νΈν™ μ λ¬΄λ¥Ό νλ‹¨ν•©λ‹λ‹¤. μ΄λ¥Ό ν†µν•΄ νƒ€μ… κ°„μ— λ¶ν•„μ”ν• μ μ•½ μ—†μ΄ μ μ—°ν• μ½”λ“ μ‘μ„±μ΄ κ°€λ¥ν•©λ‹λ‹¤.
```typescript
// μΈν„°νμ΄μ¤ Aμ™€ B μ •μ
interface A {
  x: number;
}

interface B {
  x: number;
  y: number;
}

// Aλ” Bλ΅ ν• λ‹Ή κ°€λ¥ν•©λ‹λ‹¤. (λ„μΉλ”κ±΄ κ°€λ¥)
let a: A = { x: 1 };
let b: B = a; // κ°€λ¥

// Bλ” Aλ΅ ν• λ‹Ή λ¶κ°€λ¥ν•©λ‹λ‹¤. (λ¶€μ΅±ν•κ±΄ λ¶κ°€λ¥)
let bb: B = { x: 1, y: 2 };
let aa: A = bb; // μ¤λ¥! Property 'y'κ°€ ν•„μ”ν•©λ‹λ‹¤.
```

### 2. **ν•¨μ νƒ€μ…μ νΈν™μ„±** 
ν•¨μμ μ—­μ‹ κµ¬μ΅°μ  νƒ€μ΄ν•‘ κ΄€μ •μ—μ„ ν•¨μ κµ¬μ΅°κ°€ μ μ‚¬ν•λ©΄ νΈν™μ΄ κ°€λ¥ν•©λ‹λ‹¤. λ§¤κ°λ³€μμ™€ λ°ν™ νƒ€μ…μ΄ λ‹¤λ¥Έ ν•¨μμ λ™μ‘μ„ λ³΄μ¥ν•΄ μ¤„ μ μλ‹¤λ©΄ ν•΄λ‹Ή ν•¨μλ” νΈν™μ΄ κ°€λ¥ν•©λ‹λ‹¤.

```typescript
type FuncA = (x: number) => number;
type FuncB = (x: number, y: number) => number;

// FuncAλ” FuncBλ΅ ν• λ‹Ή κ°€λ¥ν•©λ‹λ‹¤. (λ§¤κ°λ³€μκ°€ μ μ–΄μ§€λ”κ±΄ κ°€λ¥)
let fnA: FuncA = (x) => x * 2;
let fnB: FuncB = fnA; // κ°€λ¥

// FuncBλ” FuncAλ΅ ν• λ‹Ή λ¶κ°€λ¥ν•©λ‹λ‹¤.  (λ§¤κ°λ³€μκ°€ λ§μ•„μ§€λ”κ±΄ λ¶κ°€λ¥)
let fnBB: FuncB = (x, y) => x + y;
let fnAA: FuncA = fnBB; // μ¤λ¥! λ¶ν•„μ”ν• λ§¤κ°λ³€μ 'y'κ°€ μμµλ‹λ‹¤.
```

### 3. **μ΄λ„μ νΈν™μ„±** 
νƒ€μ…μ¤ν¬λ¦½νΈμ μ΄λ„μ€ μ§μ ‘ κ°’μ„ ν• λ‹Ήν•΄μ£Όμ§€ μ•μΌλ©΄ μ«μκ°’μ΄ μ§€μ •μ΄ λ©λ‹λ‹¤. μ΄λ¬ν• μ«μν• μ΄λ„μ€ number typeκ³Ό νΈν™λ©λ‹λ‹¤. 
```typescript
// μ΄λ„μ νΈν™μ„± μμ‹
enum Direction {
  Up, //0
  Down, //1
  Left, //2
  Right, //3
}

let directionValue: Direction;
directionValue = Direction.Up; // κ°€λ¥
directionValue = 1; // κ°€λ¥, μ«μ κ°’ ν• λ‹Ήλ„ κ°€λ¥

let anotherDirection: Direction;
anotherDirection = "Left"; // μ¤λ¥! λ¬Έμμ—΄μ€ μ΄λ„κ³Ό νΈν™λμ§€ μ•μµλ‹λ‹¤.
```
> μ΄λ„μ€ μ΄λ„νƒ€μ…κ°„μ€ νΈν™μ΄ λ¶κ°€λ¥ν•©λ‹λ‹¤. **λ”°λΌμ„ μ΄λ„μ€ κµ¬μ΅°μ  νƒ€μ΄ν•‘κ°λ…μ΄ μ μ© λμ§€ μ•μµλ‹λ‹¤.**
```typescript
enum Color {
  Red,
  Green,
  Blue,
}
enum Shape {
  Circle,
  Square,
  Triangle,
}
let colorValue: Color = Color.Red;
let shapeValue: Shape = Shape.Circle;
colorValue = shapeValue; // μ¤λ¥! μ΄λ„ νƒ€μ… κ°„ νΈν™ λ¶κ°€λ¥
```

### 4. **μ λ„¤λ¦­μ νΈν™μ„±** 
μ λ„¤λ¦­μ€ λ°›μ€ νƒ€μ…μ„ ν†µν•΄ μΌλ°μ μΈ νƒ€μ…νΈν™κ³Ό κ°™κ² λ™μ‘ν•©λ‹λ‹¤. ν•μ§€λ§ λ§μ•½ λ°›μ€ νƒ€μ…μ΄ ν•΄λ‹Ή κµ¬μ΅°μ—μ„ μ‚¬μ©λμ§€ μ•λ”λ‹¤λ©΄ νƒ€μ…νΈν™μ μν–¥μ„ μ£Όμ§€ μ•μµλ‹λ‹¤.

```typescript
// μ λ„¤λ¦­μ νΈν™μ„± μμ‹
interface Box<T> {
  value: T;
}

let box1: Box<number>;
let box2: Box<string>;

box1 = box2; // μ¤λ¥! μ λ„¤λ¦­μ νƒ€μ…μ΄ λ‹¤λ¥΄κΈ° λ•λ¬Έμ— νΈν™λμ§€ μ•μµλ‹λ‹¤.

// ν•μ§€λ§ μ λ„¤λ¦­ νƒ€μ…μ΄ μ‹¤μ λ΅ μ‚¬μ©λλ” κ²½μ°μ—λ” νΈν™λ©λ‹λ‹¤.
let numBox: Box<number>;
let anyBox: Box<any>;

numBox = anyBox; // κ°€λ¥, 'any' νƒ€μ…μ€ λ¨λ“  νƒ€μ…κ³Ό νΈν™λ©λ‹λ‹¤.
```

